### 1.递归取最大值：
	思路：通过递归一直划分为左右两段，f(0,1)和f(2,3),然后再继续划分为f(0,0),f(1,1),f(2,2),f(3,3)，到这一层会达到递归调用结束条件，最终返回相应的最大值，然后返回给f(0,1),f(2,3)，再比较这俩较大值，最终返回给f(0,3)，得到最终结果。
	![[recursion getMax.png]] 
	![[Getmax.png]]
	原理：调用系统栈，将现有函数的所有内容存储在栈底，然后函数语句中调用本身压入此函数栈中，优先执行新压入的函数操作。一旦返回了就依次将值返回给调用它的函数中去。递归行为都可以改成非递归行为。
	![[recursion.png]]
### 2.时间复杂度
	T(N)=aT(N/b)+O(N^d)     
	子问题的规模是一致的，都是N/b，子问题调用了a次，剩下的复杂度是O(N^d)       
	这个例子中是T(N)=2T(N/2)+O(N^0)；   0是因为只有一句其他语句,是常数项个，是O(1)==>N^d=1-->d=0
	还可以变为取原问题的前2/3和后2/3，T(N)=2(2N/3)+O(N^0)
	确定复杂度：
	(1)logba > d     O(N^logba)
	(2)logba < d     O(N^d)
	(3)logba == d    O(N^d*logN)