### 1.算法优劣的核心指标：
	（1）时间复杂度（流程决定）   （2）空间复杂度（流程决定）  
	（3）常数项时间（实现细节决定）
### 2.常数时间操作：
	一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。这样的操作称为常数时间的操作。
	例如常见的算术运算（+、-、*、/、%）   位运算（>>、>>>、|、&、^）
	java中>>:带符号右移（最高位补的数同符号位）   
	          >>>:不带符号右移（最高位直接补0）	
	赋值、比较、自增、自减等操作          数组寻址操作：通过偏移量直接寻
### 3.三种复杂度为n2的排序（从小往大排）
    1.选择排序 
      设置一个minIndex指代当前最小元素的索引值，用两层循环逐个寻找最小的元素并和外层循环开始的元素交换，最终的复杂度为n2；
      问题：minIndex多次寻找并比较，每一次都需要遍历剩下的数组
      事例：数组{3,6，4,7,8,9,1,2,5}；第一个minIndex值是1；容器中存储的是3和2，剩下的数组值均大于3，故先在容器中寻找minIndex
      解决：可以新建一个数组或容器收集存储过的minIndex值，如果容器为空则在剩下的数组中遍历，否则在容器中寻找minIndex
		![[selection sort.png]]
	2.冒泡排序
	   从第一个元素一直往后比较，遇到逆序的就交换，直到最后一个，第一层比较n-1次，最差交换n-1次，n-1对，然后是n-2对，最终是1对，故复杂度是n2；每次是将最大的元素置到最后位置上
	   ![[bubble sort.p
	3.插入排序
		逐个保持前数组有序，并遍历插入现有数组；从0-0，一个元素，就是有序的；0-1，arr[1]和arr[0]比较，大者放右边，此时0-1有序；0-n，arr[n]先与arr[n-1]比较，然后在有序的0--n-1数组中从arr[n-1]开始依次找arr[n]>arr[i]&&arr[n]<arr[i+1]的位置，并插入到里面，现将大于arr[n]部分后移一个单位，然后将arr[n]填入arr[i+1]中
		最差情况：数组逆序，时间复杂度为n2
		最好情况：数组顺序，时间复杂度为n
		![[insertion sort.png]]
### 4.空间复杂度
	与用户的需求无关，指的是除开用户需求（输入输出空间）之外的额外开辟的空间；如需求为返回一个数组，那么在函数中开辟一个数组之后，空间复杂度仍未O(1)；不然的话为O(n)；
### 5.常数项时间（最次要）
	当两个算法的时间复杂度等级相同时，直接运行比较运行的时间，而不是分析常数项花的时间，这样难分析而且太过于细枝末节，直接比运行时间即可。